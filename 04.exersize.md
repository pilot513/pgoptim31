# Exercise: 04
---

## Settings for PostgreSQL Server
   [Cybertec PG Calculator](https://pgconfigurator.cybertec-postgresql.com/)

<details><summary>Конфигурация PostgreSQL Server</summary>

```bash
# Connectivity
max_connections = 520
superuser_reserved_connections = 3

# Memory Settings
shared_buffers = '4096 MB'
work_mem = '32 MB'
maintenance_work_mem = '320 MB'
huge_pages = off
effective_cache_size = '11 GB'
effective_io_concurrency = 100 # concurrent IO only really activated if OS supports posix_fadvise function
random_page_cost = 1.25 # speed of random disk access relative to sequential access (1.0)

# Monitoring
shared_preload_libraries = 'pg_stat_statements' # per statement resource usage stats
track_io_timing=on # measure exact block IO times
track_functions=pl # track execution times of pl-language procedures if any

# Replication
wal_level = replica # consider using at least 'replica'
max_wal_senders = 10
synchronous_commit = on

# Checkpointing:
checkpoint_timeout = '15 min'
checkpoint_completion_target = 0.9
max_wal_size = '1024 MB'
min_wal_size = '512 MB'

# WAL archiving
archive_mode = on # having it on enables activating P.I.T.R. at a later time without restart›
archive_command = '/bin/true' # not doing anything yet with WAL-s


# WAL writing
wal_compression = on
wal_buffers = -1 # auto-tuned by Postgres till maximum of segment size (16MB by default)
wal_writer_delay = 200ms
wal_writer_flush_after = 1MB
wal_keep_size = '3650 MB'


# Background writer
bgwriter_delay = 200ms
bgwriter_lru_maxpages = 100
bgwriter_lru_multiplier = 2.0
bgwriter_flush_after = 0

# Parallel queries:
max_worker_processes = 8
max_parallel_workers_per_gather = 4
max_parallel_maintenance_workers = 4
max_parallel_workers = 8
parallel_leader_participation = on

# Advanced features
enable_partitionwise_join = on
enable_partitionwise_aggregate = on
jit = on
max_slot_wal_keep_size = '1000 MB'
track_wal_io_timing = on
maintenance_io_concurrency = 100
wal_recycle = on

# General notes:
# Note that not all settings are automatically tuned.
# Consider contacting experts at
# https://www.cybertec-postgresql.com
# for more professional expertise.
```
</details>

---

| synchronous_commit setting | local durable commit | standby durable commit after PG crash | standby durable commit after OS crash | standby query consistency |
|----------------------------|:--------------------:|:-------------------------------------:|:-------------------------------------:|:-------------------------:|
| remote_apply               | •                    | •                                     | •                          | •              |
| on                         | •                    | •                                     | •                          |                |
| remote_write               | •                    | •                                     |                            |                |
| local                      | •                    |                                       |                            |                |
| off                        |                      |                                       |                            |                |

---

## Configure the Primary Server (Master):

* Load database [`thai`](https://storage.googleapis.com/thaibus/thai_medium.tar.gz) _medium_ size:
  ```bash
  wget https://storage.googleapis.com/thaibus/thai_medium.tar.gz && tar -xf thai_medium.tar.gz
  ```

  ```bash
  
  export PGPASSWORD=postgres;
  time psql -h localhost -p 5432 -U postgres < thai.sql
  
  ```
  real	**2m54,407s**
  user	0m6,611s
  sys	0m3,424s


* Create db user ``replicator`` on master node:
  > "Чтобы использовать протокол репликации, клиент должен подключаться к серверу под ролью, имеющей атрибут REPLICATION (либо под суперпользователем). В pg_hba.conf надо разрешить подключение этой роли к базе данных replication (это, конечно, не название БД, а ключевое слово). Причем разрешения для all недостаточно, replication должен быть разрешен отдельно" [протокол потоковой репликации](https://postgrespro.ru/docs/postgresql/17/protocol-replication). _Общее количество слотов репликации_, которые могут быть созданы, ограничено конфигурационным параметром `max_replication_slots`
  ```bash
  psql -c "CREATE USER replicator WITH REPLICATION ENCRYPTED PASSWORD 'P@ssw0rd';"
  ```

  ```sql
  postgres=# \du+
                                            Список ролей
    Имя роли  |                                Атрибуты                                 | Описание 
  ------------+-------------------------------------------------------------------------+----------
   pmm        | Суперпользователь                                                       | 
   postgres   | Суперпользователь, Создаёт роли, Создаёт БД, Репликация, Пропускать RLS | 
   replicator | Репликация                                                              |
  ```

* Create _replication slot_ `test` on **master** node:
  > для возможности восстановления кластера на другом сервере при помощи `pg_basebackup` и проведения репликации, создадим слот репликации `test` [26.2.6. Слоты репликации](https://postgrespro.ru/docs/postgresql/17/warm-standby#STREAMING-REPLICATION-SLOTS)
  ```bash
  psql -c "SELECT pg_create_physical_replication_slot('test');"
  ```

* Create `.pgpass` file for access to db replication for ``replicator`` user:
  ```bash
  cat >> ~/.pgpass << 'EOL'
  xu22-pgr01:5432:*:replicator:P@ssw0rd
  EOL
  
  chmod 0600 ~/.pgpass
  ```

  * **Node: Replica:** `postgres@xu22-pgr02` Get backup from `Master` node:
    > При помощи утилиты [`pg_basebackup`](https://postgrespro.ru/docs/postgresql/17/app-pgbasebackup) выполняем восстановление на реплике, используя ранее созданный слот репликации `test` и пользователя `replicator`. Для передачи журнальных записей `pg_basebackup`, начиная с 10-й версии, **PostgreSQL** _по умолчанию_ использует _временный слот репликации_, который существует только на время соединения и удаляется при завершении работы `pg_basebackup`. 

    > Однако в параметрах утилиты можно указать и имя обычного слота, который должен существовать на момент запуска утилиты или создаваться ей. Если предполагается немедленно развернуть новый сервер из резервной копии, удобно вызывать `pg_basebackup` с форматом `plain`  (используется по умолчанию), запуская его на целевом сервере. Утилита удаленно подключается к серверу-источнику и создает локальные каталоги и файлы, соответствующие каталогам и файлам основного сервера. Таким образом, новый сервер можно запускать, как только отработает `pg_basebackup`.

  * Создадим автономную резервную копию, используя созданный слот. С ключом `-R` утилита создает файлы, необходимые для будущей реплики.

    ```bash
    export PGPASSWORD=P@ssword
    time pg_basebackup -h xu22-pgr01 -p 5432 -U replicator -R -S test -D /var/lib/postgresql/17/main
    ```

    real    **1m8,566s**
    user    0m8,318s
    sys     0m17,420s

    > По умолчанию реплика будет «горячей», то есть сможет выполнять запросы во время восстановления. Если такая возможность не нужна, реплику можно сделать «теплой» (`hot_standby = off`). Утилита также создала сигнальный файл `standby.signal`, наличие которого указывает серверу войти в режим постоянного восстановления.

    > Журнальные записи, необходимые для восстановления согласованности, реплика получит от мастера по протоколу репликации. Далее она войдет в режим непрерывного восстановления и продолжит получать и проигрывать поток записей.

---

### Test for INSERT with ``workload2.sql`` load profile with ``pgbench``

* Create _Write profile_ as file `workload2.sql`
   ```bash
   cat > ./workload2.sql << 'EOL'
   INSERT INTO book.tickets (fkRide, fio, contact, fkSeat)
   VALUES (
       ceil(random()*100)
       , (array(SELECT fam FROM book.fam))[ceil(random()*110)]::text || ' ' ||
       (array(SELECT nam FROM book.nam))[ceil(random()*110)]::text
       ,('{"phone":"+7' || (1000000000::bigint + floor(random()*9000000000)::bigint)::text || '"}')::jsonb
       , ceil(random()*100));
   
   EOL
   ```

* **Master node:** PGBENCH test:
  ```bash
  export PGPASSWORD=postgres; /usr/lib/postgresql/17/bin/pgbench -c 8 -j 4 -T 10 -f ./workload2.sql -n -U postgres -p 5432 thai
  ```

* **Replica node:** Start PostgreSQL server

  <details><summary>OS Filesystem после восстановления: </summary>
  
   ```bash
   root@xu22-pgr02:/home/pilot/PMM_CL3# ll /var/lib/postgresql/17/main/
   итого 272
   drwx------ 19 postgres postgres   4096 апр 13 22:13 ./
   drwxr-xr-x  4 postgres postgres   4096 апр 13 21:59 ../
   -rw-------  1 postgres postgres    227 апр 13 22:13 backup_label
   -rw-------  1 postgres postgres 187813 апр 13 22:13 backup_manifest
   drwx------  6 postgres postgres   4096 апр 13 22:13 base/
   drwx------  2 postgres postgres   4096 апр 13 22:13 global/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_commit_ts/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_dynshmem/
   drwx------  4 postgres postgres   4096 апр 13 22:13 pg_logical/
   drwx------  4 postgres postgres   4096 апр 13 22:13 pg_multixact/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_notify/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_replslot/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_serial/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_snapshots/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_stat/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_stat_tmp/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_subtrans/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_tblspc/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_twophase/
   -rw-------  1 postgres postgres      3 апр 13 22:13 PG_VERSION
   drwx------  4 postgres postgres   4096 апр 13 22:13 pg_wal/
   drwx------  2 postgres postgres   4096 апр 13 22:13 pg_xact/
   -rw-------  1 postgres postgres    449 апр 13 22:13 postgresql.auto.conf
   -rw-------  1 postgres postgres      0 апр 13 22:13 standby.signal
   ```
  </details>

  - До этого момента `postgresql.service` сервис был остановлен, и тест был без синхронизации
    ```bash
    root@xu22-pgr02:/home/pilot/PMM_CL3# systemctl start postgresql.service
    root@xu22-pgr02:/home/pilot/PMM_CL3# systemctl status postgresql.service
    ● postgresql.service - PostgreSQL RDBMS
         Loaded: loaded (/lib/systemd/system/postgresql.service; disabled; vendor preset: enabled)
         Active: active (exited) since Sun 2025-04-13 22:33:33 MSK; 4s ago
        Process: 60048 ExecStart=/bin/true (code=exited, status=0/SUCCESS)
       Main PID: 60048 (code=exited, status=0/SUCCESS)
            CPU: 1ms
    
    апр 13 22:33:33 xu22-pgr02 systemd[1]: Starting PostgreSQL RDBMS...
    апр 13 22:33:33 xu22-pgr02 systemd[1]: Finished PostgreSQL RDBMS.
    ```

* Проверим статус кластера PostgreSQL
  ```bash
  
  root@xu22-pgr02:/home/pilot/PMM_CL3# pg_lsclusters 
  Ver Cluster Port Status          Owner    Data directory              Log file
  17  main    5432 online,recovery postgres /var/lib/postgresql/17/main /var/log/postgresql/postgresql-17-main.log
  ```

  <details><summary>Процессы выполняемые на реплике:</summary>

  ```bash
  root@xu22-pgr02:/home/pilot# ps -o pid,command --ppid `sudo head -n 1 /var/lib/postgresql/17/main/postmaster.pid`
    PID COMMAND
   1033 postgres: xu22pgr02: checkpointer 
   1034 postgres: xu22pgr02: background writer 
   1035 postgres: xu22pgr02: startup recovering 000000010000000200000075
   1076 postgres: xu22pgr02: walreceiver streaming 2/756362B8
   1464 postgres: xu22pgr02: postgres postgres 127.0.0.1(40648) idle
   1517 postgres: xu22pgr02: pmm postgres 127.0.0.1(40738) idle
   ```
  </details>

  <details><summary>Процессы выполняемые на мастере:</summary>

  > процесс `wal sender`, обслуживает подключение по протоколу репликации
  ```bash
  root@xu22-pgr01:/home/pilot# ps -o pid,command --ppid `sudo head -n 1 /var/lib/postgresql/17/main/postmaster.pid`
    PID COMMAND
   1043 postgres: 17/main: checkpointer 
   1044 postgres: 17/main: background writer 
   1063 postgres: 17/main: walwriter 
   1064 postgres: 17/main: autovacuum launcher 
   1068 postgres: 17/main: logical replication launcher 
   1163 postgres: 17/main: walsender replicator 192.168.10.142(54498) streaming 2/756362B8
   2918 postgres: 17/main: postgres postgres 127.0.0.1(43978) idle
   3020 postgres: 17/main: pmm postgres 127.0.0.1(35336) idle
   3439 postgres: 17/main: postgres postgres [local] idle
  ```
  </details>

- **реплику** от мастера можно отличить с помощью функции `pg_is_in_recovery()`:
  ```bash
  root@xu22-pgr02:/home/pilot/PMM_CL3# sudo su - postgres
  postgres@xu22-pgr02:~$ psql -d thai -c "select pg_is_in_recovery();"
   pg_is_in_recovery 
  -------------------
   t
  (1 строка)
  Время: 0,960 мс
  
  postgres@xu22-pgr02:~$ psql -d thai -c "select count(*) from book.tickets;"
    count   
  ----------
   54033443
  (1 строка)
  Время: 3571,639 мс (00:03,572)
  ```

* **Replica node:** test for SELECT with ``workload.sql`` load profile:

  - Подготовим профиль `ReadOnly` (SELECT) как файл `workload.sql`
    ```bash
    cat > ./workload.sql << EOL
    
    \set r random(1, 5000000) 
    SELECT id, fkRide, fio, contact, fkSeat FROM book.tickets WHERE id = :r;
    EOL
    ```

  - проведём тест с профилем `ReadOnly` (SELECT) (**Master**)
    ```bash
    $ export PGPASSWORD=postgres; /usr/lib/postgresql/17/bin/pgbench -h localhost -p 5432 -U postgres -c 8 -j 4 -T 10 -f ./workload.sql -n thai
    pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
    transaction type: ./workload.sql
    scaling factor: 1
    query mode: simple
    number of clients: 8
    number of threads: 4
    maximum number of tries: 1
    duration: 10 s
    number of transactions actually processed: 282417
    number of failed transactions: 0 (0.000%)
    latency average = 0.282 ms
    initial connection time = 78.691 ms
    ```
    **tps = 28387.261360** (without initial connection time)

*  **Master node:**
  - Проверим состояние `synchronous_commit`
    ```bash
    $ export PGPASSWORD=postgres; psql -h localhost -p 5432 -U postgres -c "SHOW synchronous_commit;"
     synchronous_commit 
    --------------------
     on
    
    $ export PGPASSWORD=postgres; psql -h xu22-pgr01 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
    Секундомер включён.
      count   
    ----------
     54033443
    
    Время: 3267,742 мс (00:03,268)
    ```

  - Test for `WriteProfile` (INSERT) on Master node again:
    ```bash
    pilot@xu22-pgr01:~/PG-OPT31$ export PGPASSWORD=postgres; /usr/lib/postgresql/17/bin/pgbench -h localhost -p 5432 -U postgres -c 8 -j 4 -T 10 -f ./workload2.sql -n thai
    pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
    transaction type: ./workload2.sql
    scaling factor: 1
    query mode: simple
    number of clients: 8
    number of threads: 4
    maximum number of tries: 1
    duration: 10 s
    number of transactions actually processed: 27271
    number of failed transactions: 0 (0.000%)
    latency average = 2.911 ms
    initial connection time = 83.435 ms
    ```
    **tps = 2748.445250** (without initial connection time)

  - Посчитаем записи обратившись к каждой ноде отдельно
    ```bash
    pilot@xu22-pgr01:~/PG-OPT31$ export PGPASSWORD=postgres; psql -h xu22-pgr01 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
      count   
    ----------
     54060714
    Время: 1683,558 мс (00:01,684)
    
    pilot@xu22-pgr01:~/PG-OPT31$ export PGPASSWORD=postgres; psql -h xu22-pgr02 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
      count   
    ----------
     54060714
    Время: 1775,946 мс (00:01,776)
    ```

- Остановим реплику и проведём тест с `Master` по записи:
  ```bash
  root@xu22-pgr02:/home/pilot/PG-OPT31# systemctl stop postgresql.service
  
  pilot@xu22-pgr01:~/PG-OPT31$ export PGPASSWORD=postgres; psql -h xu22-pgr01 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
    count   
  ----------
   54060714
  Время: 1670,022 мс (00:01,670)
  ```

- Запустим тест с INSERT (**Master**)
  ```bash
  pilot@xu22-pgr01:~/PG-OPT31$ export PGPASSWORD=postgres; /usr/lib/postgresql/17/bin/pgbench -h xu22-pgr01 -p 5432 -U postgres -c 8 -j 4 -T 10 -f ./workload2.sql -n thai
  pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
  transaction type: ./workload2.sql
  scaling factor: 1
  query mode: simple
  number of clients: 8
  number of threads: 4
  maximum number of tries: 1
  duration: 10 s
  number of transactions actually processed: 36276
  number of failed transactions: 0 (0.000%)
  latency average = 2.188 ms
  initial connection time = 82.544 ms
  ```
  **tps = 3656.977967** (without initial connection time) (**БОЛЬШЕ**)

* <details><summary> Запустим тест с SELECT (master->master, master->replica)</summary>

  ```bash
  pilot@xu22-pgr01:~/PG-OPT31$ /usr/lib/postgresql/17/bin/pgbench -h xu22-pgr01 -p 5432 -U postgres -c 8 -j 4 -T 10 -f ./workload.sql -n thai
  pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
  transaction type: ./workload.sql
  scaling factor: 1
  query mode: simple
  number of clients: 8
  number of threads: 4
  maximum number of tries: 1
  duration: 10 s
  number of transactions actually processed: 256721
  number of failed transactions: 0 (0.000%)
  latency average = 0.309 ms
  initial connection time = 77.158 ms
  ```
  **tps = 25859.438704** (without initial connection time)

  ```bash
  pilot@xu22-pgr01:~/PG-OPT31$ /usr/lib/postgresql/17/bin/pgbench -h xu22-pgr02 -p 5432 -U postgres -c 8 -j 4 -T 10 -f ./workload.sql -n thai
  pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
  transaction type: ./workload.sql
  scaling factor: 1
  query mode: simple
  number of clients: 8
  number of threads: 4
  maximum number of tries: 1
  duration: 10 s
  number of transactions actually processed: 142620
  number of failed transactions: 0 (0.000%)
  latency average = 0.557 ms
  initial connection time = 75.125 ms
  ```
  **tps = 14368.289421** (without initial connection time)

  > при master->replica заметно влияние сети 

  </details>

* <details><summary> Запустим тест с SELECT (replica->replica, replica->master)</summary>

  ```bash
  pilot@xu22-pgr02:~/PG-OPT31$ /usr/lib/postgresql/17/bin/pgbench -h xu22-pgr02 -p 5432 -U postgres -c 8 -j 4 -T 10 -f ./workload.sql -n thai
  pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
  transaction type: ./workload.sql
  scaling factor: 1
  query mode: simple
  number of clients: 8
  number of threads: 4
  maximum number of tries: 1
  duration: 10 s
  number of transactions actually processed: 276859
  number of failed transactions: 0 (0.000%)
  latency average = 0.287 ms
  initial connection time = 90.928 ms
  ```
  **tps = 27877.319615** (without initial connection time)

  ```bash
  pilot@xu22-pgr02:~/PG-OPT31$ /usr/lib/postgresql/17/bin/pgbench -h xu22-pgr01 -p 5432 -U postgres -c 8 -j 4 -T 10 -f ./workload.sql -n thai
  pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
  transaction type: ./workload.sql
  scaling factor: 1
  query mode: simple
  number of clients: 8
  number of threads: 4
  maximum number of tries: 1
  duration: 10 s
  number of transactions actually processed: 151499
  number of failed transactions: 0 (0.000%)
  latency average = 0.524 ms
  initial connection time = 85.223 ms
  ```
  **tps = 15278.799593** (without initial connection time)

  > при replica->master заметно влияние сети 

  </details>


- Посчитаем записи после добавления
   ```bash
   pilot@xu22-pgr01:~/PG-OPT31$ export PGPASSWORD=postgres; psql -h xu22-pgr01 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
     count   
   ----------
    54096990
   Время: 1684,762 мс (00:01,685)
   
   # --- Реплика выключена и недоступна:
   pilot@xu22-pgr01:~/PG-OPT31$ export PGPASSWORD=postgres; psql -h xu22-pgr02 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
   psql: ошибка: подключиться к серверу "xu22-pgr02" (192.168.10.142), порту 5432 не удалось: В соединении отказано
           Сервер действительно работает по данному адресу и принимает TCP-соединения?
   ```

- Стартуем сервер на реплике, и проверяем, что записи "доехали":
  ```bash
  root@xu22-pgr02:/home/pilot/PG-OPT31# systemctl start postgresql.service
  
  pilot@xu22-pgr01:~/PG-OPT31$ export PGPASSWORD=postgres; psql -h xu22-pgr02 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
    count   
  ----------
   54096990
  Время: 3186,053 мс (00:03,186)
  ```

- Ещё раз проводим нагрузку с уже работающей репликой (идёт синхронизация) и сравниваем tps:
  ```bash
  pilot@xu22-pgr01:~/PG-OPT31$ export PGPASSWORD=postgres; /usr/lib/postgresql/17/bin/pgbench -h localhost -p 5432 -U postgres -c 8 -j 4 -T 10 -f ./workload2.sql -n thai
  pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
  transaction type: ./workload2.sql
  scaling factor: 1
  query mode: simple
  number of clients: 8
  number of threads: 4
  maximum number of tries: 1
  duration: 10 s
  number of transactions actually processed: 26988
  number of failed transactions: 0 (0.000%)
  latency average = 2.938 ms
  initial connection time = 92.766 ms
  ```
  **tps = 2722.638607** (without initial connection time) (**МЕНЬШЕ**)

### ВЫВОД:
    > При включённой синхронизации скорость выполнения запросов на запись - медленее

---

## Операции на реплике:

* Допускаются:
  - запросы на чтение данных (select, copy to, курсоры)
    - реплика может выполнять запросы на чтение данных, если установлен параметр `hot_standby = on`
  - установка параметров сервера (set, reset)
  - управление транзакциями (begin, commit, rollback...)
  - создание резервной копии (pg_basebackup)
* Не допускаются:
  - любые изменения (insert, update, delete, truncate, nextval...)
  - блокировки, предполагающие изменение (select for update...)
  - команды DDL (create, drop...), в том числе создание временных таблиц
  - команды сопровождения (vacuum, analyze, reindex...)
  - управление доступом (grant, revoke...)

* При выполнении резервного копирования с реплики нет технической возможности полноценно управлять мастером, в частности, вызывать контрольные точки и включать параметр `full_page_writes`. Поэтому параметр нужно _включить на мастере заранее_, а контрольную точку приходится ждать (что может существенно задержать процесс).
* Не поддерживается уровень изоляции `serializable` на реплике.
* Создание табличных пространств реплицируется, но, если у пользователя ОС, под которым работает СУБД, недостаточно прав для создания каталога, произойдет ошибка. Лучше всего сначала создать каталоги на мастере и на всех репликах, а уже затем выполнять команду `CREATE TABLESPACE`

---

## Исследование режимов репликации

* Фиксация транзакций может выполняться в двух режимах.
  - в более быстром **асинхронном режиме** есть шанс потерять уже зафиксированные изменения в случае сбоя
  - в **синхронном режиме** команда COMMIT не завершается, пока запись не дойдет до диска.
* При наличии нескольких серверов надежность можно еще более увеличить, дожидаясь подтверждения от реплики о получении записи, тогда данные не пропадут даже при выходе из строя носителя.
  - **Синхронная репликация** включается тем же параметром `synchronous_commit`, что и синхронная фиксация. Разные значения этого параметра позволяют управлять уровнем надежности. 
    - при значении `remote_write` мастер ожидает подтверждения о получении записи (остается шанс потерять изменения, если на реплике случится сбой и она не успеет записать данные на диск)
    - при значении `on` мастер ожидает подтверждения о попадании журнальной записи на диск реплики (это надежный режим; однако приложение, обратившись к реплике, может не увидеть изменений).
    - значение `remote_apply` заставляет мастер дождаться применения записи на реплике. 
  - Каждый следующий режим вызывает все большие задержки.
* Мастер может синхронизироваться как с одной, так и с несколькими репликами. Можно указать список реплик в порядке приоритета или организовать синхронизацию на основе кворума, при которой мастер дожидается подтверждения от любых `N` реплик из числа доступных.

* Возможные проблемы при репликации и пути их решения (и предотвращения)
  > Сервер PostgreSQL периодически удаляет файлы журнала (WAL), которые не требуются для восстановления. При этом мастер может удалить файл, который содержит данные, еще не переданные реплике
    - не проблема, если используется архив журналов предзаписи, поскольку реплика, получив отказ по протоколу репликации, прочитает необходимые ей данные из архива, а затем, «догнав» мастер, снова переключится на получение данных из потока
    - если архива нет, реплика не сможет продолжать восстановление и ее придется пересоздавать из новой резервной копии. Чтобы этого избежать, можно использовать слот репликации. Однако надо понимать, что создание слота _ставит мастер в зависимость от реплики_: если реплика не будет получать журнальные записи, они будут накапливаться на мастере и свободное пространство рано или поздно закончится. Поэтому слот — еще одна точка, которую необходимо включать в мониторинг.

* бесперебойная работа основного сервера важнее, чем синхронизация реплики.
<details><summary> Чтобы предотвратить разрастание журнала, можно ограничить объем, удерживаемый слотом: </summary>

  ```sql
  ALTER SYSTEM SET max_slot_wal_keep_size='32MB';
  SELECT pg_reload_conf();
  ```
  - контроль журнала
    ```sql
    SELECT pg_size_pretty(sum(size)) FROM pg_ls_waldir();
    ```

  - при недоступности архива (или если это вообще он не был настроен), получаем отсутствие записей WAL (`wal_status=lost`) на стороне реплики
    ```sql
    SELECT active, restart_lsn, wal_status FROM pg_replication_slots \gx
    -[ RECORD 1 ]-----
    active      | f
    restart_lsn | 
    wal_status  | lost
    ```
    - и соответствующие ошибки в логе кластера: `root@xu22-pgr02:/home/pilot# tail -n3 /var/log/postgresql/postgresql-17-main.log`
    ```bash
    2025-05-04 15:49:58.989 MSK [11864] LOG:  started streaming WAL from primary at 0/9000000 on timeline 1
    2025-05-04 15:49:58.989 MSK [11864] FATAL:  could not receive data from WAL stream: ERROR:  requested WAL segment 000000010000000000000009 has already been removed
    ```
  > Для синхронизации реплики в таких случаях можно воспользоваться архивом, задав параметр restore_command. Если это невозможно, придется заново настроить репликацию, повторив формирование базовой копии.
</details>

### Настройка режима `remote_apply` (`async`)

<details><summary> Настройка в `remote_apply` (async) режиме </summary>

* **Replica node:** добавляем имя кластера на реплике:

  - Set postgres Cluster name to ``cluster_name='xu22pgr02'``
  - **ВНИМАНИЕ!** имя кластера должно быть без дефиса! (`xu22pgr02`)

    ```bash
    root@xu22-pgr02:/home/pilot/PG-OPT31# sudo su - postgres
    postgres@xu22-pgr02:~$ psql
    psql (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
    postgres@postgres=# alter system set cluster_name='xu22pgr02';
    ALTER SYSTEM

    postgres@postgres=# \dconfig cluster_name
    Список параметров конфигурации
    Параметр      | Значение  
    --------------+-----------
    cluster_name  | xu22pgr02

    postgres@postgres=# \q
    
    postgres@xu22-pgr02:~$ 
    выход
    
    root@xu22-pgr02:/home/pilot/PG-OPT31# cat /var/lib/postgresql/17/main/postgresql.auto.conf 
    # Do not edit this file manually!
    # It will be overwritten by the ALTER SYSTEM command.
    primary_conninfo = 'user=replicator password=''P@ssw0rd'' channel_binding=prefer host=''xu22-pgr01'' port=5432 sslmode=prefer sslnegotiation=postgres sslcompression=0 sslcertmode=allow sslsni=1 ssl_min_protocol_version=TLSv1.2 gssencmode=prefer krbsrvname=postgres gssdelegation=0 target_session_attrs=any load_balance_hosts=disable'
    primary_slot_name = 'test'
    cluster_name = 'xu22pgr02'
    ```

- **Master node:** ``synchronous_commit`` to `remote_apply` mode:
  ```bash
  export PGPASSWORD=postgres; 
  psql -h localhost -p 5432 -U postgres -c "ALTER SYSTEM SET synchronous_commit='remote_apply';"
  psql -h localhost -p 5432 -U postgres -c "ALTER SYSTEM SET synchronous_standby_names ='xu22pgr02';"
  ```

- Рестартуем PostgreSQL на **Master**
  ```bash
  root@xu22-pgr01:/home/pilot/PG-OPT31# systemctl stop postgresql.service
  root@xu22-pgr01:/home/pilot/PG-OPT31# systemctl start postgresql.service
  root@xu22-pgr01:/home/pilot/PG-OPT31# systemctl status postgresql.service
  ● postgresql.service - PostgreSQL RDBMS
       Loaded: loaded (/lib/systemd/system/postgresql.service; enabled; vendor preset: enabled)
       Active: active (exited) since Sun 2025-04-13 23:19:58 MSK; 4s ago
      Process: 112508 ExecStart=/bin/true (code=exited, status=0/SUCCESS)
     Main PID: 112508 (code=exited, status=0/SUCCESS)
          CPU: 2ms
  
  апр 13 23:19:58 xu22-pgr01 systemd[1]: Starting PostgreSQL RDBMS...
  апр 13 23:19:58 xu22-pgr01 systemd[1]: Finished PostgreSQL RDBMS.
  ```

- Проверим _статус_ репликации на **Master**
  > поля `*_lsn` (и `*_lag`) показывают отставание реплики на разных этапах. Сейчас все позиции совпадают, отставание нулевое

  ```bash
  root@xu22-pgr01:/home/pilot/PG-OPT31# sudo su - postgres
  postgres@xu22-pgr01:~$ psql
  Секундомер включён.
  psql (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
  Введите "help", чтобы получить справку.

  postgres@postgres=# select application_name, client_addr, sync_state from pg_stat_replication;
   application_name |  client_addr   | sync_state 
  ------------------+----------------+------------
   xu22pgr02        | 192.168.10.142 | sync
  
  postgres@postgres=# SELECT * FROM pg_stat_replication \gx
  -[ RECORD 1 ]----+------------------------------
  pid              | 112524
  usesysid         | 16547
  usename          | replicator
  application_name | 17/main
  client_addr      | 192.168.10.142
  client_hostname  | 
  client_port      | 54138
  backend_start    | 2025-04-13 23:20:00.301484+03
  backend_xmin     | 
  state            | streaming
  sent_lsn         | 2/24A113A0
  write_lsn        | 2/24A113A0
  flush_lsn        | 2/24A113A0
  replay_lsn       | 2/24A113A0
  write_lag        | 
  flush_lag        | 
  replay_lag       | 
  sync_priority    | 0
  sync_state       | async
  reply_time       | 2025-04-13 23:20:31.247225+03
  
  Время: 4,217 мс
  postgres@postgres=#
  ```

- Или обычный вывод (длинный)
  ```bash
  postgres@postgres=# select * from pg_stat_activity where application_name='psql';
   datid | datname  |  pid   | leader_pid | usesysid | usename  | application_name | client_addr | client_hostname | client_port |        backend_start         |          xact_start           |          query_star>
  -------+----------+--------+------------+----------+----------+------------------+-------------+-----------------+-------------+------------------------------+-------------------------------+-------------------->
       5 | postgres | 112676 |            |       10 | postgres | psql             |             |                 |          -1 | 2025-04-13 23:20:38.00797+03 | 2025-04-13 23:22:57.619963+03 | 2025-04-13 23:22:57>
  ```

</details>

### Настройка режима `local` (`async`)

<details><summary> Тестирование в `local` (async) режиме: </summary>

**Проведём тестирование:**

* вставим в большое количество строк, чтобы увидеть репликацию в процессе работы (Master)

```bash
pilot@xu22-pgr01:~/PG-OPT31$ /usr/lib/postgresql/17/bin/pgbench -h localhost -p 5432 -U postgres -c 2 -j 2 -T 10 -f ./workload2.sql -n thai
pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
transaction type: ./workload2.sql
scaling factor: 1
query mode: simple
number of clients: 2
number of threads: 2
maximum number of tries: 1
duration: 10 s
number of transactions actually processed: 6203
number of failed transactions: 0 (0.000%)
latency average = 3.215 ms
initial connection time = 31.908 ms
```
**tps = 622.153457** (without initial connection time)

  - состояние во время репликации
    ```bash
    postgres@postgres=# SELECT *, pg_current_wal_lsn() from pg_stat_replication \gx
    -[ RECORD 1 ]------+------------------------------
    pid                | 1163
    usesysid           | 16547
    usename            | replicator
    application_name   | xu22pgr02
    client_addr        | 192.168.10.142
    client_hostname    | 
    client_port        | 54498
    backend_start      | 2025-05-04 13:48:58.605452+03
    backend_xmin       | 
    state              | streaming
    sent_lsn           | 2/75B93C18
    write_lsn          | 2/75B93C18
    flush_lsn          | 2/75B93AC8
    replay_lsn         | 2/75B93AC8
    write_lag          | 00:00:00.000235
    flush_lag          | 00:00:00.000235
    replay_lag         | 00:00:00.000235
    sync_priority      | 1
    sync_state         | sync
    reply_time         | 2025-05-04 15:19:17.296135+03
    pg_current_wal_lsn | 2/75B93C18
    ```

  - состояние после репликации (синхронизировано)
    ```bash
    postgres@postgres=# SELECT *, pg_current_wal_lsn() from pg_stat_replication \gx
    -[ RECORD 1 ]------+------------------------------
    pid                | 1163
    usesysid           | 16547
    usename            | replicator
    application_name   | xu22pgr02
    client_addr        | 192.168.10.142
    client_hostname    | 
    client_port        | 54498
    backend_start      | 2025-05-04 13:48:58.605452+03
    backend_xmin       | 
    state              | streaming
    sent_lsn           | 2/75BF0530
    write_lsn          | 2/75BF0530
    flush_lsn          | 2/75BF0530
    replay_lsn         | 2/75BF0530
    write_lag          | 
    flush_lag          | 
    replay_lag         | 
    sync_priority      | 1
    sync_state         | sync
    reply_time         | 2025-05-04 15:19:29.038819+03
    pg_current_wal_lsn | 2/75BF0530
    ```

---

- Set on **Master node** ``synchronous_commit`` to `local` mode:
  ```bash
  export PGPASSWORD=postgres; 
  psql -h localhost -p 5432 -U postgres -c "ALTER SYSTEM SET synchronous_commit='local';"
  psql -h localhost -p 5432 -U postgres -c "ALTER SYSTEM SET synchronous_standby_names ='';"
  ```

- Рестартуем PostgreSQL на **Master**
  ```bash
  root@xu22-pgr01:/home/pilot/PG-OPT31# systemctl stop postgresql.service
  root@xu22-pgr01:/home/pilot/PG-OPT31# systemctl start postgresql.service
  root@xu22-pgr01:/home/pilot/PG-OPT31# systemctl status postgresql.service
  ● postgresql.service - PostgreSQL RDBMS
     Loaded: loaded (/lib/systemd/system/postgresql.service; enabled; vendor preset: enabled)
     Active: active (exited) since Sun 2025-05-04 17:41:26 MSK; 2s ago
    Process: 68360 ExecStart=/bin/true (code=exited, status=0/SUCCESS)
   Main PID: 68360 (code=exited, status=0/SUCCESS)
        CPU: 2ms

   мая 04 17:41:26 xu22-pgr01 systemd[1]: Starting PostgreSQL RDBMS...
   мая 04 17:41:26 xu22-pgr01 systemd[1]: Finished PostgreSQL RDBMS.

   pilot@xu22-pgr01:~/PG-OPT31$ pg_lsclusters 
   Ver Cluster Port Status Owner    Data directory              Log file
   17  main    5432 online postgres /var/lib/postgresql/17/main /var/log/postgresql/postgresql-17-main.log
  ```

- статус репликации на Master (**async**)
  ```sql
  postgres@postgres=# SELECT *, pg_current_wal_lsn() from pg_stat_replication \gx
  -[ RECORD 1 ]------+------------------------------
  pid                | 68372
  usesysid           | 16547
  usename            | replicator
  application_name   | xu22pgr02
  client_addr        | 192.168.10.142
  client_hostname    | 
  client_port        | 49320
  backend_start      | 2025-05-04 17:41:28.143371+03
  backend_xmin       | 
  state              | streaming
  sent_lsn           | 2/777F23B8
  write_lsn          | 2/777F23B8
  flush_lsn          | 2/777F23B8
  replay_lsn         | 2/777F23B8
  write_lag          | 
  flush_lag          | 
  replay_lag         | 
  sync_priority      | 0
  sync_state         | async
  reply_time         | 2025-05-04 17:43:54.333253+03
  pg_current_wal_lsn | 2/777F23B8
  ```
- статус репликации на реплике
  ```sql
  postgres@postgres=# SELECT
  pg_is_in_recovery() AS is_slave,
  pg_last_wal_receive_lsn() AS receive,
  pg_last_wal_replay_lsn() AS replay,
  pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() AS synced,
  (
   EXTRACT(EPOCH FROM now()) -
   EXTRACT(EPOCH FROM pg_last_xact_replay_timestamp())
  )::int AS lag;

   is_slave |  receive   |   replay   | synced | lag 
  ----------+------------+------------+--------+-----
   t        | 2/777F23B8 | 2/777F23B8 | t      | 304
  ```

  #### Тестируем INSERT (Master)

* Посчитаем записи перед тестированием 
  ```bash
  pilot@xu22-pgr01:~/PG-OPT31$ psql -h xu22-pgr01 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
  count   
  ----------
   54177677

  Время: 3295,707 мс (00:03,296)

  pilot@xu22-pgr01:~/PG-OPT31$ psql -h xu22-pgr02 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
    count   
  ----------
   54177677
  (1 строка)
  
  Время: 1844,689 мс (00:01,845)
  ```
* Запустим тестирование INSERT (Master)
  ```bash
  pilot@xu22-pgr01:~/PG-OPT31$ /usr/lib/postgresql/17/bin/pgbench -h localhost -p 5432 -U postgres -c 2 -j 2 -T 10 -f ./workload2.sql -n thai
  pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
  transaction type: ./workload2.sql
  scaling factor: 1
  query mode: simple
  number of clients: 2
  number of threads: 2
  maximum number of tries: 1
  duration: 10 s
  number of transactions actually processed: 7228
  number of failed transactions: 0 (0.000%)
  latency average = 2.759 ms
  initial connection time = 32.739 ms
  ```
  **tps = 724.951657** (without initial connection time)

* Посчитаем записи после тестирования
  ```bash
  pilot@xu22-pgr01:~/PG-OPT31$ psql -h xu22-pgr01 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
    count   
  ----------
   54184905
  (1 строка)
  
  Время: 1835,157 мс (00:01,835)
  pilot@xu22-pgr01:~/PG-OPT31$ psql -h xu22-pgr02 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
    count   
  ----------
   54184905
  (1 строка)
  
  Время: 1690,240 мс (00:01,690)
  ```

> репликация активна 

  - Master
    ```sql
    postgres@postgres=# SELECT active, restart_lsn, wal_status FROM pg_replication_slots \gx
    -[ RECORD 1 ]-----------
    active      | t
    restart_lsn | 2/77EBF2E8
    wal_status  | reserved
    ```
  - Replica
    ```sql
      postgres@postgres=# SELECT
      pg_is_in_recovery() AS is_slave,
      pg_last_wal_receive_lsn() AS receive,
      pg_last_wal_replay_lsn() AS replay,
      pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() AS synced,
      (
       EXTRACT(EPOCH FROM now()) -
       EXTRACT(EPOCH FROM pg_last_xact_replay_timestamp())
      )::int AS lag;

     is_slave |  receive   |   replay   | synced | lag 
    ----------+------------+------------+--------+-----
     t        | 2/77EBF2E8 | 2/77EBF2E8 | t      | 231
    ```
    - log 
      ```bash
      root@xu22-pgr02:/home/pilot/PG-OPT31# tail -n3 /var/log/postgresql/postgresql-17-main.log
      2025-05-04 17:48:55.031 MSK [39233] СООБЩЕНИЕ:  точка перезапуска завершена: записано буферов: 548 (0.1%); добавлено файлов WAL 0, удалено: 0, переработано: 0;\
                                                      запись=57.120 сек., синхр.=0.102 сек., всего=57.236 cек.; \
                                                      синхронизировано_файлов=119, самая_долгая_синхр.=0.003 сек., средняя=0.001 сек.; расстояние=2121 kB, ожидалось=5162 kB;\
                                                      lsn=2/777CDB70, lsn redo=2/777CDB70
      2025-05-04 17:48:55.031 MSK [39233] СООБЩЕНИЕ:  точка перезапуска восстановления в позиции 2/777CDB70
      2025-05-04 17:48:55.031 MSK [39233] ПОДРОБНОСТИ:  Последняя завершённая транзакция была выполнена в 2025-05-04 17:48:26.08587+03.
      ```
    - Остановим реплику
      ```bash
      root@xu22-pgr02:/home/pilot/PG-OPT31# systemctl stop postgresql.service; pg_lsclusters
      Ver Cluster Port Status        Owner    Data directory              Log file
      17  main    5432 down,recovery postgres /var/lib/postgresql/17/main /var/log/postgresql/postgresql-17-main.log
      ```
    - на Master видим состояние репликации (неактивно)
      ```sql
      postgres@postgres=# SELECT active, restart_lsn, wal_status FROM pg_replication_slots \gx
      -[ RECORD 1 ]-----------
      active      | f
      restart_lsn | 2/780C2608
      wal_status  | reserved
      ```
    - посчитаем записи, затем выполним вставку без работающей реплики 
      ```bash
      pilot@xu22-pgr01:~/PG-OPT31$ psql -h xu22-pgr01 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
        count   
      ----------
       54192415
      

      pilot@xu22-pgr01:~/PG-OPT31$ /usr/lib/postgresql/17/bin/pgbench -h localhost -p 5432 -U postgres -c 2 -j 2 -T 10 -f ./workload2.sql -n thai
      pgbench (17.4 (Ubuntu 17.4-1.pgdg22.04+2))
      transaction type: ./workload2.sql
      scaling factor: 1
      query mode: simple
      number of clients: 2
      number of threads: 2
      maximum number of tries: 1
      duration: 10 s
      number of transactions actually processed: 9700
      number of failed transactions: 0 (0.000%)
      latency average = 2.056 ms
      initial connection time = 31.712 ms
      tps = 972.886945 (without initial connection time)


      pilot@xu22-pgr01:~/PG-OPT31$ psql -h xu22-pgr01 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
        count   
      ----------
       54202115
      ```

    - стартуем реплику, видим, что записи "доехали"
      ```bash
      pilot@xu22-pgr01:~/PG-OPT31$ psql -h xu22-pgr02 -p 5432 -U postgres -d thai -c "select count(*) from book.tickets;"
      Секундомер включён.
        count   
      ----------
       54202115
      ```

</details>

### Влияние параметра [`hot_standby_feedback`](https://postgrespro.ru/docs/postgresql/17/runtime-config-replication#GUC-HOT-STANDBY-FEEDBACK)
   > Определяет, будет ли сервер горячего резерва сообщать ведущему или вышестоящему ведомому о запросах, которые он выполняет в данный момент. Это позволяет исключить необходимость отмены запросов, вызванную очисткой записей, но при некоторых типах нагрузки это может приводить к раздуванию базы данных на ведущем сервере. Эти сообщения о запросах будут отправляться не чаще, чем раз в интервал, задаваемый параметром `wal_receiver_status_interval`. Значение данного параметра по умолчанию — off. Задать этот параметр можно только в `postgresql.conf` или в командной строке при запуске сервера.
Если используется каскадная репликация, сообщения о запросах передаются выше, пока в итоге не достигнут ведущего сервера. На промежуточных серверах эта информация больше никак не задействуется.

- сейчас этот параметр выключен
  ```sql
  postgres@postgres=# SHOW hot_standby_feedback;
   hot_standby_feedback 
  ----------------------
   off
  ```

   > Когда параметр `hot_standby` на резервном сервере установлен в `true`, то он начинает принимать соединения сразу как только система придёт в согласованное состояние в процессе восстановления. Для таких соединений будет разрешено только чтение, запись невозможна даже во временные таблицы.

   > Для того, чтобы данные с ведущего сервера были получены на резервном, требуется некоторое время. Таким образом, имеется измеряемая задержка между ведущим и резервным серверами. Поэтому запуск одинаковых запросов примерно в одно время на ведущем и резервном серверах может вернуть разный результат. Можно сказать, что данные на резервном сервере в конечном счёте согласуются с ведущим. После того как запись о зафиксированной транзакции воспроизводится на резервном сервере, изменения, совершённые в этой транзакции, становится видны в любых последующих снимках данных на резервном сервере. Снимок может быть сделан в начале каждого запроса или в начале каждой транзакции в зависимости от уровня изоляции транзакции

   > В случае, если количество отменённых запросов на резервном сервере получается неприемлемым, существует ряд дополнительных возможностей. Первая возможность — установить параметр `hot_standby_feedback`, который не даёт команде VACUUM удалять записи, ставшие недействительными недавно, что предотвращает конфликты очистки. При этом следует учесть, что это вызывает задержку очистки мёртвых строк на ведущем, что может привести к нежелательному распуханию таблицы. Тем не менее в итоге ситуация будет не хуже, чем если бы запросы к резервному серверу исполнялись непосредственно на ведущем, но при этом сохранится положительный эффект от разделения нагрузки. В случае, когда соединение резервных серверов с ведущим часто разрывается, следует скорректировать период, в течение которого обратная связь через `hot_standby_feedback` не обеспечивается. Например, следует подумать об увеличении `max_standby_archive_delay`, чтобы запросы отменялись не сразу при конфликтах с архивом WAL в период разъединения. Также может иметь смысл увеличить `max_standby_streaming_delay` для предотвращения быстрой отмены запросов из-за полученных записей WAL после восстановления соединения.

   > Другая возможность — увеличение `vacuum_defer_cleanup_age` на ведущем сервере таким образом, чтобы мёртвые записи не очищались бы так быстро, как при обычном режиме работы. Это даёт запросам на резервном сервере больше времени на выполнение, прежде чем они могут быть отменены, без увеличения задержки `max_standby_streaming_delay`. Тем не менее при таком подходе очень трудно обеспечить какое-то определённое окно по времени, так как `vacuum_defer_cleanup_age` измеряется в количестве транзакций, выполняемых на ведущем сервере.

   > Количество отменённых запросов и причины отмены можно просмотреть через системное представление `pg_stat_database_conflicts` на резервном сервере. Системное представление `pg_stat_database` так же содержит итоговую информацию

   [26.4. Горячий резерв](https://postgrespro.ru/docs/postgresql/17/hot-standby#HOT-STANDBY-CONFLICT)

---
### Настройка режима `on` (`async`) и проверка обратной связи (`hot_standby_feedback`)

<details><summary>выполним настройки для исследования в режиме `synchronous_commit=on`</summary>

* `synchronous_commit: on`

  ```bash
  export PGPASSWORD=postgres; 
  psql -h localhost -p 5432 -U postgres -c "ALTER SYSTEM SET synchronous_commit='on';"
  psql -h localhost -p 5432 -U postgres -c "ALTER SYSTEM SET synchronous_standby_names ='xu22pgr02';"
  ```

* Restart service PostgreSQL (Master)
  ```bash
  root@xu22-pgr01:/home/pilot/PG-OPT31# systemctl stop postgresql.service; sleep 3; systemctl start postgresql.service;
  root@xu22-pgr01:/home/pilot/PG-OPT31# systemctl status postgresql.service
  ● postgresql.service - PostgreSQL RDBMS
     Loaded: loaded (/lib/systemd/system/postgresql.service; enabled; vendor preset: enabled)
     Active: active (exited) since Sun 2025-05-04 18:38:09 MSK; 2min 32s ago
    Process: 81626 ExecStart=/bin/true (code=exited, status=0/SUCCESS)
   Main PID: 81626 (code=exited, status=0/SUCCESS)
        CPU: 1ms

   мая 04 18:38:09 xu22-pgr01 systemd[1]: Starting PostgreSQL RDBMS...
   мая 04 18:38:09 xu22-pgr01 systemd[1]: Finished PostgreSQL RDBMS.

   root@xu22-pgr01:/home/pilot# pg_lsclusters
   Ver Cluster Port Status Owner    Data directory              Log file
   17  main    5432 online postgres /var/lib/postgresql/17/main /var/log/postgresql/postgresql-17-main.log
  ```

* Статус репликации на (Master)
  ```sql
  postgres@postgres=# SELECT *, pg_current_wal_lsn() from pg_stat_replication \gx
   -[ RECORD 1 ]------+------------------------------
   pid                | 81620
   usesysid           | 16547
   usename            | replicator
   application_name   | xu22pgr02
   client_addr        | 192.168.10.142
   client_hostname    | 
   client_port        | 49860
   backend_start      | 2025-05-04 18:38:08.987721+03
   backend_xmin       | 
   state              | streaming
   sent_lsn           | 2/78BED068
   write_lsn          | 2/78BED068
   flush_lsn          | 2/78BED068
   replay_lsn         | 2/78BED068
   write_lag          | 
   flush_lag          | 
   replay_lag         | 
   sync_priority      | 1
   sync_state         | sync
   reply_time         | 2025-05-04 18:42:09.233298+03
   pg_current_wal_lsn | 2/78BED068
  ```

* Статус репликации на реплике
  ```sql
  postgres@postgres=# SHOW hot_standby_feedback;        
   hot_standby_feedback 
  ----------------------
   off
  
  postgres@postgres=# SHOW wal_receiver_status_interval;
   wal_receiver_status_interval 
  ------------------------------
   10s
  
  postgres@postgres=# SELECT                            
    pg_is_in_recovery() AS is_slave,
    pg_last_wal_receive_lsn() AS receive,
    pg_last_wal_replay_lsn() AS replay,
    pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() AS synced,
    (
     EXTRACT(EPOCH FROM now()) -
     EXTRACT(EPOCH FROM pg_last_xact_replay_timestamp())
    )::int AS lag;

   is_slave |  receive   |   replay   | synced | lag 
  ----------+------------+------------+--------+-----
   t        | 2/78BED068 | 2/78BED068 | t      | 214
  ```


* Создадим тестовую базу `test` (Master)
  ```sql
  CREATE DATABASE test;
  ```

  - Видим её на реплике
    ```sql
    postgres@postgres=# \l test
                                                 Список баз данных
     Имя  | Владелец | Кодировка | Провайдер локали | LC_COLLATE  |  LC_CTYPE   | Локаль | Правила ICU | Права доступа 
    ------+----------+-----------+------------------+-------------+-------------+--------+-------------+---------------
     test | postgres | UTF8      | libc             | ru_RU.UTF-8 | ru_RU.UTF-8 |        |             | 

    ```

* Синхронизация работает (Master)
  ```sql
  postgres@postgres=# SHOW synchronous_commit;
    synchronous_commit 
   --------------------
    on
   (1 строка)
   
   Время: 1,043 мс
   postgres@postgres=# SHOW synchronous_standby_names;
    synchronous_standby_names 
   ---------------------------
    xu22pgr02
   (1 строка)
   
   Время: 0,288 мс
   postgres@postgres=# SELECT * FROM pg_stat_replication \gx
   -[ RECORD 1 ]----+------------------------------
   pid              | 81620
   usesysid         | 16547
   usename          | replicator
   application_name | xu22pgr02
   client_addr      | 192.168.10.142
   client_hostname  | 
   client_port      | 49860
   backend_start    | 2025-05-04 18:38:08.987721+03
   backend_xmin     | 
   state            | streaming
   sent_lsn         | 2/7918C9B8
   write_lsn        | 2/7918C9B8
   flush_lsn        | 2/7918C9B8
   replay_lsn       | 2/7918C9B8
   write_lag        | 
   flush_lag        | 
   replay_lag       | 
   sync_priority    | 1
   sync_state       | sync
   reply_time       | 2025-05-04 19:02:54.885788+03
  ```

* **Остановим реплику**
  ```bash
  root@xu22-pgr02:/home/pilot/PG-OPT31# systemctl stop postgresql.service; sleep 2; pg_lsclusters
  Ver Cluster Port Status        Owner    Data directory              Log file
  17  main    5432 down,recovery postgres /var/lib/postgresql/17/main /var/log/postgresql/postgresql-17-main.log
  ```

  1. Цепляемся на **Master** к базе `test` и пытаемся открыть транзакцию на создание таблицы
     - пока реплика выключена, на стадии `COMMIT` - висим:
       ```sql
       postgres@test=# \c test
       Вы подключены к базе данных "test" как пользователь "postgres".
       postgres@test=# BEGIN;
       BEGIN
       Время: 0,783 мс
       postgres@test=*# CREATE TABLE test(id integer);
       CREATE TABLE
       Время: 6,542 мс
       postgres@test=*# COMMIT;
       COMMIT
       Время: 10526,410 мс (00:10,526)
       ```

     - стартуем реплику, и транзакция завершается
       ```sql
       postgres@test=# \d
           Список отношений
        Схема  | Имя  |   Тип   | Владелец 
       --------+------+---------+----------
        public | test | таблица | postgres
       ```

  2. **Отмена запроса из-за очистки на мастере**

    - На **Master** добавляем запись:
      ```sql
      postgres@test=# INSERT INTO test VALUES (1);
      INSERT 0 1
      Время: 3,493 мс

      postgres@test=# SELECT * FROM test;
       id 
      ----
        1
      (1 строка)
      
      Время: 0,677 мс
      ```

    - На реплике (**Replica**):
      ```sql
      postgres@test=# BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
      BEGIN
      Время: 0,792 мс
      postgres@test=*# SELECT * FROM test;
       id 
      ----
        1
      (1 строка)
      Время: 0,897 мс
      ```
      ```
    - в это время на **Master** обновляем запись в таблице, и выполняем её очистку (`VACUUM`):
      ```sql
      postgres@test=# UPDATE test SET id = 2;
      UPDATE 1
      Время: 8,060 мс
      postgres@test=# VACUUM test;
      VACUUM
      Время: 1,128 мс
      ```

    - через 30 сек на реплике получаем ошибки. Запрос аварийно прерван, поскольку версия строки, входящая в снимок, больше не существует.
      ```sql
      postgres@test=*# SELECT * FROM test;
      ВАЖНО:  закрытие подключения из-за конфликта с процессом восстановления
      ПОДРОБНОСТИ:  Запросу пользователя нужно было видеть версии строк, которые должны быть удалены.
      ПОДСКАЗКА:  Вы сможете переподключиться к базе данных и повторить вашу команду сию минуту.
      сервер неожиданно закрыл соединение
              Скорее всего сервер прекратил работу из-за сбоя
              до или в процессе выполнения запроса.
      Подключение к серверу потеряно. Попытка восстановления удачна.
      Время: 3,901 мс
      ```

  3. **Запрет откладывания применения конфликтующей записи**

    - На реплике (**Replica**):
      ```sql
      ALTER SYSTEM SET max_standby_streaming_delay = 0;
      ```
      - реастартуем PostgreSQL
        ```bash
        root@xu22-pgr02:/home/pilot/PG-OPT31# pg_ctlcluster 17 main reload
        ```
      - проверяем установки
        ```sql
        postgres@test=# SHOW max_standby_streaming_delay;
        max_standby_streaming_delay 
        -----------------------------
        0
        ```
      - смотрим содержимое и начинаем запрос в изоляции
        ```sql
        postgres@test=# \d test
                                    Таблица "public.test"
          Столбец |   Тип   | Правило сортировки | Допустимость NULL | По умолчанию 
         ---------+---------+--------------------+-------------------+--------------
          id      | integer |                    |                   | 
         
         postgres@test=# SELECT * FROM test;
          id 
         ----
           2
        ```
        - на Master изменяем запись и идём на Replica
          ```sql
          postgres@test=# UPDATE test SET id = 3;
          UPDATE 1
          Время: 12,426 мс

          postgres@test=# VACUUM test;
          VACUUM
          Время: 1,247 мс
          ```
        - на Replica пытаемся выполнить запрос, который сразу падает 
          ```sql
          postgres@test=# BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
          BEGIN
          Время: 0,287 мс

          postgres@test=*# SELECT * FROM test;
          ВАЖНО:  закрытие подключения из-за конфликта с процессом восстановления
          ПОДРОБНОСТИ:  Запросу пользователя нужно было видеть версии строк, которые должны быть удалены.
          ПОДСКАЗКА:  Вы сможете переподключиться к базе данных и повторить вашу команду сию минуту.
          сервер неожиданно закрыл соединение
                  Скорее всего сервер прекратил работу из-за сбоя
                  до или в процессе выполнения запроса.
          Подключение к серверу потеряно. Попытка восстановления удачна.
          Время: 4,815 мс
          ```

  4. **Обратная связь** (`hot_standby_feedback`)

    - на Replica примерим `hot_standby_feedback = on` и интервал оповещений мастера `wal_receiver_status_interval` в `1sec`
      ```sql
      postgres@postgres=# SHOW hot_standby_feedback;
       hot_standby_feedback 
      ----------------------
       off
      
      postgres@postgres=# ALTER SYSTEM SET hot_standby_feedback = on;
      ALTER SYSTEM
      Время: 13,066 мс
      postgres@postgres=# SHOW wal_receiver_status_interval;
       wal_receiver_status_interval 
      ------------------------------
       10s
      
      postgres@postgres=# ALTER SYSTEM SET wal_receiver_status_interval = '1s';
      ALTER SYSTEM
      ```

    - реастартуем PostgreSQL (Replica)
      ```bash
      root@xu22-pgr02:/home/pilot/PG-OPT31# pg_ctlcluster 17 main reload
      ```

    - на Master изменяем запись и пытаемся выполнить VACUUM, получая ошибку
      > Благодаря обратной связи, очистка не может удалить старую версию строки (удалено: 0, осталось: 2, «мёртвых», но ещё не подлежащих удалению: 1)

      ```sql
      postgres@test=# UPDATE test SET id = 4;
      UPDATE 1
      Время: 10,433 мс
      postgres@test=# VACUUM VERBOSE test;
      ИНФОРМАЦИЯ:  очистка "test.public.test"
      ИНФОРМАЦИЯ:  закончена очистка "test.public.test": сканирований индекса: 0
      страниц удалено: 0, осталось: 1, просканировано: 1 (100.00% от общего числа)
      версий строк: удалено: 0, осталось: 2, «мёртвых», но ещё не подлежащих удалению: 1
      XID отсечки удаления: 212525, на момент завершения операции он имел возраст: 1 XID
      новое значение relminmxid: 18935, оно продвинулось вперёд от предыдущего значения на 4 MXID
      замораживание: на страницах таблицы (0, 0.00% от общего числа) заморожено кортежей: 0
      сканирование индекса не требуется: на страницах таблицы (0, 0.00% от общего числа) удалено мёртвых идентификаторов элементов: 0
      время ввода/вывода: чтение: 0.000 мс, запись: 0.000 мс
      средняя скорость чтения: 0.000 МБ/с, средняя скорость записи: 117.481 МБ/с
      использование буфера: попаданий: 11, промахов: 0, «грязных» записей: 4
      использование WAL: записей: 1, полных образов страниц: 1, байт: 356
      нагрузка системы: CPU: пользов.: 0.00 с, система: 0.00 с, прошло: 0.00 с
      VACUUM
      Время: 0,776 мс
      ```

    - после завершения начатой транзакции на **Replica**
      ```sql
      postgres@test=*# COMMIT;
      COMMIT
      Время: 0,384 мс
      ```
      - на Master можно выполнить очистку VACUUM (удалено: 1, осталось: 1, «мёртвых», но ещё не подлежащих удалению: 0)
        ```sql
        postgres@test=# VACUUM VERBOSE test;
        ИНФОРМАЦИЯ:  очистка "test.public.test"
        ИНФОРМАЦИЯ:  закончена очистка "test.public.test": сканирований индекса: 0
        страниц удалено: 0, осталось: 1, просканировано: 1 (100.00% от общего числа)
        версий строк: удалено: 1, осталось: 1, «мёртвых», но ещё не подлежащих удалению: 0
        XID отсечки удаления: 212538, на момент завершения операции он имел возраст: 0 XID
        новое значение relfrozenxid: 212525, оно продвинулось вперёд от предыдущего значения на 52 XID
        новое значение relminmxid: 18936, оно продвинулось вперёд от предыдущего значения на 1 MXID
        замораживание: на страницах таблицы (0, 0.00% от общего числа) заморожено кортежей: 0
        сканирование индекса не требуется: на страницах таблицы (0, 0.00% от общего числа) удалено мёртвых идентификаторов элементов: 0
        время ввода/вывода: чтение: 0.000 мс, запись: 0.000 мс
        средняя скорость чтения: 0.000 МБ/с, средняя скорость записи: 0.000 МБ/с
        использование буфера: попаданий: 12, промахов: 0, «грязных» записей: 0
        использование WAL: записей: 3, полных образов страниц: 1, байт: 436
        нагрузка системы: CPU: пользов.: 0.00 с, система: 0.00 с, прошло: 0.00 с
        VACUUM
        Время: 1,352 мс
        ```

    * Теперь отменим синхронизацию и остановим реплику: (Master)
      ```sql
      postgres@test=# ALTER SYSTEM RESET synchronous_standby_names;
      ALTER SYSTEM
      ```
      - Restart PostgreSQL
        ```bash
        root@xu22-pgr01:/home/pilot# systemctl stop postgresql.service; sleep 3; systemctl start postgresql.service; sleep 3; pg_lsclusters
        Ver Cluster Port Status Owner    Data directory              Log file
        17  main    5432 online postgres /var/lib/postgresql/17/main /var/log/postgresql/postgresql-17-main.log
        ```
     - Проверим применилось ли
       ```sql
       postgres@test=# SHOW synchronous_standby_names;
        synchronous_standby_names 
       ---------------------------
        
       (1 строка)
       ```
     - остановим Replica
       ```bash
       root@xu22-pgr02:/home/pilot/PG-OPT31# pg_ctlcluster 17 main stop
       root@xu22-pgr02:/home/pilot/PG-OPT31# pg_lsclusters 
       Ver Cluster Port Status        Owner    Data directory              Log file
       17  main    5432 down,recovery postgres /var/lib/postgresql/17/main /var/log/postgresql/postgresql-17-main.log
       ```
    - обновим запись в таблице (Master)
      ```sql
      postgres@test=# UPDATE test SET id = 5;
      UPDATE 1
      Время: 8,604 мс
      postgres@test=# SELECT * FROM test;
       id 
      ----
        5
      ```
    - слота репликации нет (Master), но есть запись об `xmin` снимков реплики
      ```sql
      postgres@test=# SELECT * FROM pg_stat_replication WHERE sync_state <> 'async' \gx
      (0 строк)

      postgres@test=# SELECT active, xmin FROM pg_replication_slots;
       active |  xmin  
      --------+--------
       f      | 212548
      (1 строка)
      ```
      - Значение `xmin` из слота (212548) меньше, чем минимальный `xmin` (212549) локальных снимков
        ```sql
        postgres@test=# SELECT min(backend_xmin::text::numeric) FROM pg_stat_activity;
           min   
         --------
          212549
         (1 строка)
        ```
      - Поэтому слот будет задерживать очистку (Master)
        ```sql
        postgres@test=# VACUUM VERBOSE test;
         ИНФОРМАЦИЯ:  очистка "test.public.test"
         ИНФОРМАЦИЯ:  закончена очистка "test.public.test": сканирований индекса: 0
         страниц удалено: 0, осталось: 1, просканировано: 1 (100.00% от общего числа)
         версий строк: удалено: 0, осталось: 2, «мёртвых», но ещё не подлежащих удалению: 1
         XID отсечки удаления: 212548, на момент завершения операции он имел возраст: 11 XID
         новое значение relminmxid: 18938, оно продвинулось вперёд от предыдущего значения на 2 MXID
         замораживание: на страницах таблицы (0, 0.00% от общего числа) заморожено кортежей: 0
         сканирование индекса не требуется: на страницах таблицы (0, 0.00% от общего числа) удалено мёртвых идентификаторов элементов: 0
         время ввода/вывода: чтение: 0.076 мс, запись: 0.000 мс
         средняя скорость чтения: 52.550 МБ/с, средняя скорость записи: 70.067 МБ/с
         использование буфера: попаданий: 8, промахов: 3, «грязных» записей: 4
         использование WAL: записей: 1, полных образов страниц: 1, байт: 356
         нагрузка системы: CPU: пользов.: 0.00 с, система: 0.00 с, прошло: 0.00 с
         VACUUM
         Время: 1,176 мс
        ```
    - Удалим слот репликации `test`, и попробуем выполнить очистку снова
      ```sql
      SELECT pg_drop_replication_slot('replica');
      postgres@test=# SELECT pg_drop_replication_slot('test');
        pg_drop_replication_slot 
       --------------------------
        
       (1 строка)
       Время: 4,088 мс

       postgres@test=# VACUUM VERBOSE test;
       ИНФОРМАЦИЯ:  очистка "test.public.test"
       ИНФОРМАЦИЯ:  закончена очистка "test.public.test": сканирований индекса: 0
       страниц удалено: 0, осталось: 1, просканировано: 1 (100.00% от общего числа)
       версий строк: удалено: 1, осталось: 1, «мёртвых», но ещё не подлежащих удалению: 0
       XID отсечки удаления: 212559, на момент завершения операции он имел возраст: 0 XID
       новое значение relfrozenxid: 212548, оно продвинулось вперёд от предыдущего значения на 23 XID
       замораживание: на страницах таблицы (0, 0.00% от общего числа) заморожено кортежей: 0
       сканирование индекса не требуется: на страницах таблицы (0, 0.00% от общего числа) удалено мёртвых идентификаторов элементов: 0
       время ввода/вывода: чтение: 0.000 мс, запись: 0.000 мс
       средняя скорость чтения: 0.000 МБ/с, средняя скорость записи: 17.170 МБ/с
       использование буфера: попаданий: 12, промахов: 0, «грязных» записей: 1
       использование WAL: записей: 3, полных образов страниц: 3, байт: 666
       нагрузка системы: CPU: пользов.: 0.00 с, система: 0.00 с, прошло: 0.00 с
       VACUUM
       Время: 1,211 мс
      ```

  5. **Восстановим состояние:**
    - Master
      ```sql
      postgres@postgres=# SELECT pg_create_physical_replication_slot('test');
       pg_create_physical_replication_slot 
      -------------------------------------
       (test,)
      (1 строка)
      
      postgres@postgres=# ALTER SYSTEM SET synchronous_commit='remote_apply';
      ALTER SYSTEM

      postgres@postgres=# ALTER SYSTEM SET synchronous_standby_names ='xu22pgr02';
      ALTER SYSTEM
      ```
    - **Replica:** Remove from file  `/var/lib/postgresql/17/main/postgresql.auto.conf`
      ```bash
      Remove options for file: /var/lib/postgresql/17/main/postgresql.auto.conf
      max_standby_streaming_delay = '0'
      hot_standby_feedback = 'on'
      wal_receiver_status_interval = '1s'
      ```
    - Master
      ```bash
      root@xu22-pgr01:/home/pilot# systemctl stop postgresql.service; sleep 3; systemctl start postgresql.service; sleep 3; pg_lsclusters
      Ver Cluster Port Status Owner    Data directory              Log file
      17  main    5432 online postgres /var/lib/postgresql/17/main /var/log/postgresql/postgresql-17-main.log
      ```
    - Replica
      ```bash
      root@xu22-pgr02:/home/pilot/PG-OPT31# pg_ctlcluster 17 main start
      root@xu22-pgr02:/home/pilot/PG-OPT31# pg_lsclusters 
      Ver Cluster Port Status          Owner    Data directory              Log file
      17  main    5432 online,recovery postgres /var/lib/postgresql/17/main /var/log/postgresql/postgresql-17-main.log
      ```
  6. Проверим состояние: 
     - (Master)
       ```sql
       postgres@postgres=# select application_name, client_addr, sync_state from pg_stat_replication;
         application_name |  client_addr   | sync_state 
        ------------------+----------------+------------
         xu22pgr02        | 192.168.10.142 | sync
        (1 строка)
        
        Время: 1,316 мс
        postgres@postgres=# SELECT * FROM pg_stat_replication \gx
        -[ RECORD 1 ]----+------------------------------
        pid              | 119886
        usesysid         | 16547
        usename          | replicator
        application_name | xu22pgr02
        client_addr      | 192.168.10.142
        client_hostname  | 
        client_port      | 52330
        backend_start    | 2025-05-04 21:05:07.5938+03
        backend_xmin     | 
        state            | streaming
        sent_lsn         | 2/7ADB6390
        write_lsn        | 2/7ADB6390
        flush_lsn        | 2/7ADB6390
        replay_lsn       | 2/7ADB6390
        write_lag        | 
        flush_lag        | 
        replay_lag       | 
        sync_priority    | 1
        sync_state       | sync
        reply_time       | 2025-05-04 21:09:47.992134+03
        
        Время: 1,360 мс
       ```
       - удалим тестовую базу `test`
         ```sql
         DROP DATABASE test;
         ```

     - Replica
       ```sql
       postgres@postgres=# SELECT
          pg_is_in_recovery() AS is_slave,
          pg_last_wal_receive_lsn() AS receive,
          pg_last_wal_replay_lsn() AS replay,
          pg_last_wal_receive_lsn() = pg_last_wal_replay_lsn() AS synced,
          (
           EXTRACT(EPOCH FROM now()) -
           EXTRACT(EPOCH FROM pg_last_xact_replay_timestamp())
          )::int AS lag;

         is_slave |  receive   |   replay   | synced | lag 
        ----------+------------+------------+--------+-----
         t        | 2/7AFF4EF8 | 2/7AFF4EF8 | t      |  76
        (1 строка)
       ```

</details>

     


      





---


### Matrials usaged:
   * [PostgresPRO DOC: 18.5.3. Архивация](https://postgrespro.ru/docs/postgrespro/9.5/runtime-config-wal#runtime-config-wal-archiving)
   * [PostgresPRO DOC: 24.3.1. Настройка архивирования WAL](https://postgrespro.ru/docs/postgrespro/9.5/continuous-archiving#backup-archiving-wal)
   * [SELECTEL: Резервное копирование и восстановление PostgreSQL: ``pg_dump``, ``pg_restore``, ``wal-g``](https://selectel.ru/blog/postgresql-backup-tools/)
